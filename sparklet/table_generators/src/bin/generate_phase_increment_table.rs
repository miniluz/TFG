use std::env;

use fixed::types::U8F24;

fn main() {
    let args: Vec<String> = env::args().collect();

    let wavetable_size: u32 = args.get(1).and_then(|s| s.parse().ok()).unwrap_or(256);

    let sample_rate: u32 = args.get(2).and_then(|s| s.parse().ok()).unwrap_or(48000);

    eprintln!("Generating pitch table for:");
    eprintln!("  WAVETABLE_SIZE: {}", wavetable_size);
    eprintln!("  SAMPLE_RATE: {}", sample_rate);
    eprintln!();

    println!("use fixed::types::U8F24;");
    println!();
    println!("// autogenerated using");
    println!("// just gen-phase-increment");
    println!();
    print!("pub static MIDI_TO_PHASE_INCREMENT: [U8F24; 128] = [");

    let mut a4 = U8F24::ZERO;

    for note in 0..128 {
        // Calculate frequency for this MIDI note
        let f = 440.0 * 2_f64.powf((note as f64 - 69.0) / 12.0);

        // Calculate phase increment
        let phase_increment = (wavetable_size as f64) * f / (sample_rate as f64);

        // Convert to U8F24 fixed-point format (8 integer bits, 24 fractional bits)
        // This is equivalent to multiplying by 2^24 and converting to u32
        let fixed_value = (phase_increment * (1u64 << 24) as f64) as u32;

        if note == 69 {
            a4 = U8F24::from_bits(fixed_value);
        }

        println!();
        print!("    U8F24::from_bits({:#010x}),", fixed_value);
    }

    println!();
    println!("];");

    eprintln!();
    eprintln!("Sanity check:");
    eprintln!("  Note 69 (A4): {}", a4);
    eprintln!(
        "  Validate that {} / ({} / {}) = 440",
        sample_rate, wavetable_size, a4,
    )
}
