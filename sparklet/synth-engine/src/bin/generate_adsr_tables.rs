use std::env;

use fixed::{traits::ToFixed, types::I1F31};
use synth_engine::adsr::{
    BaseAndCoefficient,
    native_utils::{
        ParamConfig, TimeConfig, get_base_and_coefficient_for_index, get_time_for_index,
        iterate_envelope,
    },
};

const SAMPLE_RATE: u32 = 48000;

pub fn base_coefficient_table_to_string(table: &[BaseAndCoefficient]) -> String {
    table.iter().map(|BaseAndCoefficient{base, coefficient}|
        std::format!("BaseAndCoefficient{{ base: I1F31::from_bits({:#010x}), coefficient: I1F31::from_bits({:#010x}) }}, ", base.to_bits() as u32, coefficient.to_bits() as u32)
    ).collect::<String>()
}

fn main() {
    let args: Vec<String> = env::args().collect();

    let target_ratio = args.get(1).and_then(|s| s.parse().ok()).unwrap_or(1.5);
    assert!(target_ratio > 0.);
    // Controls how linear/exponential the time adjustment is
    let time_control_target_ratio = args.get(2).and_then(|s| s.parse().ok()).unwrap_or(-4.8);

    eprintln!("Generating attack base and coefficient table for:");
    eprintln!("  TARGET_RATIO: {}", target_ratio);
    eprintln!("  TIME_CONTROL_TARGET_RATIO: {}", time_control_target_ratio);

    const SIZE: usize = 256;

    let mut attack_table: [BaseAndCoefficient; SIZE] = [Default::default(); SIZE];

    let attack_config = ParamConfig {
        target_ratio,
        initial: 0.,
        target: 1.,
        time_config: TimeConfig {
            rate: SIZE as f64 - 1.,
            ratio: time_control_target_ratio,
            initial: 0.01,
            target: 5.,
        },
    };

    let mut decay_release_table: [BaseAndCoefficient; SIZE] = [Default::default(); SIZE];

    let decay_release_config = ParamConfig {
        target_ratio,
        initial: 1.,
        target: 0.,
        time_config: TimeConfig {
            rate: SIZE as f64 - 1.,
            ratio: -5.9,
            initial: 0.01,
            target: 10.,
        },
    };

    let mut sanity_check_data = vec![];

    for (index, (attack_base_coefficient, decay_release_base_coefficient)) in attack_table
        .iter_mut()
        .zip(decay_release_table.iter_mut())
        .enumerate()
    {
        let attack_time = get_time_for_index::<SAMPLE_RATE>(index, attack_config.time_config);
        let decay_release_time: f64 =
            get_time_for_index::<SAMPLE_RATE>(index, decay_release_config.time_config);

        *attack_base_coefficient =
            get_base_and_coefficient_for_index::<SAMPLE_RATE>(index, attack_config);
        *decay_release_base_coefficient =
            get_base_and_coefficient_for_index::<SAMPLE_RATE>(index, decay_release_config);

        // Collect sanity check data for selected indices
        if index <= 2 || 126 <= index && index <= 128 || 253 <= index {
            let attack_iterations = (attack_time * SAMPLE_RATE as f64) as usize;
            let decay_release_iterations = (decay_release_time * SAMPLE_RATE as f64) as usize;

            let (attack_iterations, attack_final) = iterate_envelope(
                attack_base_coefficient.base,
                attack_base_coefficient.coefficient,
                I1F31::ZERO,
                attack_iterations,
            );

            let (decay_release_iterations, decay_release_final) = iterate_envelope(
                decay_release_base_coefficient.base,
                decay_release_base_coefficient.coefficient,
                I1F31::MAX,
                decay_release_iterations,
            );

            sanity_check_data.push((
                index,
                attack_time,
                attack_iterations as f64 / SAMPLE_RATE as f64,
                attack_final,
                decay_release_iterations as f64 / SAMPLE_RATE as f64,
                decay_release_time,
                decay_release_final,
            ));
        }
    }

    let contents = format!(
        "// Autogenerated by generate_adsr_tables

use fixed::types::I1F31;

#[derive(Format, Debug, Clone, Copy, PartialEq, Eq)]
pub struct BaseAndCoefficient {{
    pub base: I1F31,
    pub coefficient: I1F31,
}}

pub static ATTACK_BASE_COEFFICIENT_TABLE: [BaseAndCoefficient; {}] = [
    {}
];

pub static DECAY_RELEASE_BASE_COEFFICIENT_TABLE: [BaseAndCoefficient; {}] = [
    {}
];
",
        SIZE,
        base_coefficient_table_to_string(&attack_table),
        SIZE,
        base_coefficient_table_to_string(&decay_release_table)
    );

    println!("{}", contents);

    eprintln!("");
    eprintln!("Sanity check (index, time, final_value):");
    eprintln!("  Attack envelopes:");
    for (index, attack_time_expected, attack_time_real, attack_final, _, _, _) in &sanity_check_data
    {
        eprintln!(
            "    Index {:3}: time={:.3}s (target={:.3}s, error={:.3}s), final={:.6} (target=1.0, error={:.6})",
            index,
            attack_time_real,
            attack_time_expected,
            (attack_time_expected - attack_time_real).abs(),
            attack_final,
            (I1F31::MAX - attack_final).abs()
        );
    }
    eprintln!("  Decay/Release envelopes:");
    for (
        index,
        _,
        _,
        _,
        decay_release_time_expected,
        decay_release_time_real,
        decay_release_final,
    ) in &sanity_check_data
    {
        eprintln!(
            "    Index {:3}: time={:.3}s (target={:.3}s, error={:.3}s), final={:.6} (target=0.0, error={:.6})",
            index,
            decay_release_time_real,
            decay_release_time_expected,
            (decay_release_time_expected - decay_release_time_real).abs(),
            decay_release_final,
            (I1F31::MAX - decay_release_final).abs()
        );
    }
}
